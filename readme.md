# 低代码框架
## 1 关于项目结构和依赖包
> maven中避免重复发明轮子的方法，一种是继承，一种是引用。
* maven中配置引用关系的方法是，如果在`父项目`中使用它，应该将下面代码添加到<dependencyManagement>标记中，如果在`单独项目`中引用，直接使用下面代码即可
```
 <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>${spring-boot.version}</version>
    <type>pom</type>
    <scope>import</scope>
 </dependency>
```
很简单，这样就引入一个pom文件，这样<dependencies>里面引入对接的包，spring-boot-dependencies中配置了<version>，所以不需要再声明<version>了
```
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-eureka-server</artifactId>
```
由于没有版本信息，就可以参考引入的pom文件的<dependencyManagement>里面的版本信息,就像maven继承方法似的，在父pom的<dependencyManagement>里，放入版本信息，在若干子pom里都省去版本信息了

* 核心依赖包项目lind-dependency：pom.xml里只声明依赖，dependencyManagement管理的依赖，在被引用的子项目里，按着需要引入

* 根项目lind-fast
    * dependencyManagement不仅会引用springboot,spring-cloud,alibaba-cloud的依赖包（POM包），而且还引用lind-dependency的依赖，相当于把lind-dependency里的依赖包import到了根项目，这样方便其它子项目按需引用它
    * dependency引用了所有子项目都会用到了包，这样子项目就不需要再引用了
    * build>pluginManagement中添加了共用的插件声明，在子项目中，可以直接按着需要引用它，子项目中直接使用groupId和artifactId就可以了

## 2 关于打包时记录当前git信息
Maven打包发布版本可能会遇到自己的提交不起作用的情况，排查比较困难，可能需要拉下服务器上包，反编译查看是否包含自己的提交记录。如果使用的是GIT作为SCM，可以使用 git-commit-id-plugin插件
该插件在打包时生产一个`git.properties`文件，里面记录本次git提交的信息
```
#Generated by Git-Commit-Id-Plugin
git.build.time=2022-07-28 09\:15\:53
git.build.version=1.0.0
git.commit.id=dc8103b5cf9d51d59169e0682e9990456a72f231
git.commit.id.abbrev=dc8103b
git.commit.id.describe=dc8103b-dirty
git.commit.id.describe-short=dc8103b-dirty
git.commit.message.full=update cache log
git.commit.message.short=update cache log
git.commit.time=2022-07-28 08\:58\:43
```
* 可以在父项目中添加这个插件，这样子项目也就具有了这个能力
```
  <!--打包jar 与git commit 关联插件-->
<plugin>
    <groupId>io.github.git-commit-id</groupId>
    <artifactId>git-commit-id-maven-plugin</artifactId>
    <version>${git.commit.plugin}</version>
    <executions>
        <execution>
            <id>get-the-git-infos</id>
            <goals>
                <goal>revision</goal>
            </goals>
            <phase>initialize</phase>
        </execution>
    </executions>
    <configuration>
        <failOnNoGitDirectory>false</failOnNoGitDirectory>
        <generateGitPropertiesFile>true</generateGitPropertiesFile>
        <!--因为项目定制了jackson的日期时间序列化/反序列化格式，因此这里要进行配置,不然通过management.info.git.mode=full进行完整git信息监控时会存在问题-->
        <dateFormat>yyyy-MM-dd HH:mm:ss</dateFormat>
        <includeOnlyProperties>
            <includeOnlyProperty>^git.build.(time|version)$</includeOnlyProperty>
            <includeOnlyProperty>^git.commit.(id|message|time).*$</includeOnlyProperty>
        </includeOnlyProperties>
    </configuration>
</plugin>
```
## 3 docker打包与推送
* docker.host 表示本地的docker主机,tcp走2375端口
* docker.registry 表示私服地址，本例使用harbor做为私服
```
<plugin>
    <groupId>io.fabric8</groupId>
    <artifactId>docker-maven-plugin</artifactId>
    <version>${docker.plugin.version}</version>
    <configuration>
        <!-- Docker本地主机 -->
        <dockerHost>${docker.host}</dockerHost>
        <!-- Docker 镜像私服-->
        <registry>${docker.registry}</registry>
        <!-- 认证信息-->
        <authConfig>
            <push>
                <username>${docker.username}</username>
                <password>${docker.password}</password>
            </push>
        </authConfig>
        <images>
            <image>
                <name>${docker.registry}/${docker.namespace}/${project.name}:${project.version}</name>
                <build>
                    <dockerFile>${project.basedir}/Dockerfile</dockerFile>
                </build>
            </image>
        </images>
    </configuration>
</plugin>
```
* 本地docker主机需要开启2375这个tcp端口
```
# 打开配置文件
vi /usr/lib/systemd/system/docker.service
# 添加2375端口
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock
# 重新加载配置文件并重启服务
systemctl daemon-reload
systemctl restart docker
```
* 通过plugins的docker插件，进行build和push即可，需要注意本地docker主机与私服之间需要进行daemon.json的配置
```
{
  "registry-mirrors": ["https://ay50ucm9.mirror.aliyuncs.com","http://f2d6cb40.m.daocloud.io"],
  "insecure-registries":["http://192.168.xx.xxx:8888"]
}
```
* maven推送
```
mvn clean package docker:stop docker:remove docker:build docker:run
# 或者直接打包推送：mvn docker:build docker:push
```
* 输出
```
[INFO] --- docker-maven-plugin:0.40.1:push (default-cli) @ lind-fast-demo ---
[INFO] DOCKER> The push refers to repository [192.168.60.137:8888/lind-fast/lind-fast-demo]
edf103f27075: Preparing   
9f6bd6be39e5: Preparing   
d3f8c53ca74a: Preparing   
f9a0984f718a: Preparing   
2104e5b926f6: Preparing   
50644c29ef5a: Preparing   
50644c29ef5a: Waiting     
edf103f27075: Pushing     [>                                                  ]     512B/26.28kB
9f6bd6be39e5: Pushing      2.048kB
edf103f27075: Pushing     [==================================================>]  28.67kB
2104e5b926f6: Mounted from moxm/java 
d3f8c53ca74a: Mounted from moxm/java 
f9a0984f718a: Mounted from moxm/java 
edf103f27075: Pushed      
9f6bd6be39e5: Pushed      
50644c29ef5a: Mounted from moxm/java 
[INFO] DOCKER> 1.0.0: digest: sha256:47e560ca99e91aa73770a86991f68167510724d8a1da2820d8d3e24f64c85ddd size: 1575
[INFO] DOCKER> Temporary image tag skipped. Target image '192.168.60.137:8888/lind-fast/lind-fast-demo:1.0.0' already has registry set or no registry is available
[INFO] DOCKER> Pushed 192.168.60.137:8888/lind-fast/lind-fast-demo:1.0.0 in 3 seconds 
```
* 其它问题
如果你的docker:build失败，提示你的基础镜像不存在，我们可以把基础镜像添加到harbor中，模拟成为harbor中的镜像就可以了
